# Written expecting APT based packaging, however would be trivial to
# extend another packaging system
---
- hosts: localhost
  connection: local
  name: "Install services required for ironic"
  sudo: yes
  gather_facts: yes
  # Todo: Rip vars out, refactor.
  vars:
    - network_interface: "virbr0"
    - ironic_db_password: aSecretPassword473z
    - mysql_password: password
    - testing: true
    - http_boot_folder: /httpboot
  tasks:
    - name: "Update Package Cache"
      local_action: apt update_cache=yes
    - name: "Install packages"
      local_action: apt name={{ item }}
      with_items:
        - mysql-server
        - dnsmasq
        - rabbitmq-server
        - python-dev
        - python-pip
        - python-mysqldb
        - python-configparser
        - ipxe
        - tftp-hpa
        - syslinux
        - xinetd
        - parted
        - ipmitool
        - psmisc
        - nginx
        - wget
    - name: "Ensuring /opt/stack is present"
      local_action: file name=/opt/stack state=directory owner=root group=root
    - name: "Downloading ironic"
      local_action: command git clone https://git.openstack.org/openstack/ironic chdir=/opt/stack creates=/opt/stack/ironic
    - name: "Install ironic client"
      local_action: pip name=python-ironicclient state=present
    - name: "Install proliantutils"
      local_action: pip name=proliantutils state=present
    - name: "Starting MySQL"
      local_action: service name=mysql state=started
    - name: "Starting rabbitmq-server"
      local_action: service name=rabbitmq-server state=started
    - name: "RabbitMQ - Testing if hostname is defined firsts in /etc/hosts"
      local_action: command grep -i "127.0.0.1*.{{ ansible_hostname }}\ localhost" /etc/hosts
      ignore_errors: yes
      register: test_grep_fix_hostname
    - name: "RabbitMQ - Fixing /etc/hosts"
      local_action: command sed -i 's/localhost/{{ ansible_hostname }} localhost/' /etc/hosts
      when: test_grep_fix_hostname.rc != 0
    - name: "Ensuring guest user is removed from rabbitmq"
      local_action: rabbitmq_user user=guest state=absent force=yes
    - name: "Creating Ironic user in RabbitMQ"
      local_action: rabbitmq_user user=ironic password={{ ironic_db_password }} force=yes state=present configure_priv=.* write_priv=.* read_priv=.*
      no_log: true
    - name: "MySQL - Creating DB"
      local_action: mysql_db login_user=root login_password={{ mysql_password }} name=ironic state=present encoding=utf8
      register: test_created_db
      no_log: True
    - name: "MySQL - Creating user for Ironic"
      local_action: mysql_user login_user=root login_password={{ mysql_password }} name=ironic password={{ ironic_db_password }} priv=ironic.*:ALL state=present
      no_log: True
    - name: "Install Ironic"
      local_action: pip name=/opt/stack/ironic state=present
    - name: "Ensure /etc/ironic exists"
      local_action: file name=/etc/ironic state=directory
    - name: "Place Ironic Config file"
      local_action: template src=templates/ironic.conf.j2 dest=/etc/ironic/ironic.conf
    - name: "Copy policy.json to /etc/ironic"
      local_action: copy src=/opt/stack/ironic/etc/ironic/policy.json dest=/etc/ironic/
    - name: "Creating Ironic DB Schema"
      local_action: command ironic-dbsync --config-file /etc/ironic/ironic.conf create_schema
      when: test_created_db.changed == true
    - name: "Upgrading Ironic DB Schema"
      local_action: command ironic-dbsync --config-file /etc/ironic/ironic.conf upgrade
      when: test_created_db.changed == false
    - name: "Creating an ironic service group"
      local_action: group name=ironic
    - name: "Creating an ironic service user"
      local_action: user name=ironic group=ironic
    - name: "Placing services"
      local_action: template src=templates/init_template.j2 dest=/etc/init/{{item.service_name}}.conf owner=root group=root
      with_items:
        - { service_name: 'ironic-api', username: 'ironic', args: '--config-file /etc/ironic/ironic.conf'}
        - { service_name: 'ironic-conductor', username: 'ironic', args: '--config-file /etc/ironic/ironic.conf'}
    - name: "Start ironic-conductor"
      local_action: service name=ironic-conductor state=started
    - name: "Start ironic-api"
      local_action: service name=ironic-api state=started
    - name: "Start ironic-conductor"
      local_action: service name=ironic-conductor state=restarted
    - name: "Start ironic-api"
      local_action: service name=ironic-api state=reloaded
    - name: "Setting up PXE and iPXE folders"
      local_action: file name={{item}} owner=ironic group=ironic state=directory
      with_items:
        - /tftpboot
        - /tftpboot/pxelinux.cfg
        - "{{ http_boot_folder }}"
    - name: "Placing pxelinux.0"
      local_action: copy src=/usr/lib/syslinux/pxelinux.0 dest=/tftpboot
    - name: "Place tftp config file"
      local_action: copy src=files/xinetd.tftp dest=/etc/xinetd.d/tftp
    - name: "Copy iPXE image into place"
      local_action: copy src=/usr/lib/ipxe/undionly.kpxe dest=/tftpboot/
    - name: "Deploy dnsmasq configuration file"
      local_action: template src=templates/dnsmasq.conf.j2 dest=/etc/dnsmasq.conf 
    - name: "Deploying nginx configuraiton file for serving HTTP requests"
      local_action: template src=templates/nginx.conf.j2 dest=/etc/nginx/nginx.conf
    - name: "Ensuring dnsmasq is running"
      local_action: service name={{ item }} state=started
      with_items:
        - xinetd
        - dnsmasq
        - nginx
    - name: "Sending services a reload signal"
      local_action: service name={{ item }} state=reloaded
      with_items:
        - xinetd
        - nginx
    - name: "Sending services a force-reload signal"
      local_action: command /etc/init.d/dnsmasq force-reload
- hosts: localhost
  connection: local
  name: "Retrieve Images"
  sudo: yes
  gather_facts: yes
  vars:
    - http_boot_folder: /httpboot
  tasks:
    # Similar logic to below can be utilized to retrieve files
    - name: "Determine if folder exists, else create and populate folder."
      local_action: stat path=/tftpboot/master_images
      register: test_master_images
    - name: "Create master_images folder"
      local_action: file name=/tftpboot/master_images state=directory
      when: test_master_images.stat.exists == false
    # This is overly complex, however get_url will always re-retrieve the file
    # if it already exists, and this is to prevent that behavior.
    - name: "Test if CoreOS kernel is present"
      local_action: stat path={{ http_boot_folder }}/coreos_production_pxe.vmlinuz
      register: test_core_os_kernel_present
    - name: "Download CoreOS kernel"
      local_action: get_url url=http://tarballs.openstack.org/ironic-python-agent/coreos/files/coreos_production_pxe.vmlinuz dest={{ http_boot_folder }}/coreos_production_pxe.vmlinuz
      when: test_core_os_kernel_present.stat.exists == false
    - name: "Test if CoreOS image is present"
      local_action: stat path={{ http_boot_folder }}/coreos_production_pxe_image-oem.cpio.gz
      register: test_core_os_image_present
    - name: "Download CoreOS image"
      local_action: get_url url=http://tarballs.openstack.org/ironic-python-agent/coreos/files/coreos_production_pxe_image-oem.cpio.gz dest={{ http_boot_folder }}/coreos_production_pxe_image-oem.cpio.gz
      when: test_core_os_image_present.stat.exists == false
    - name: "Test if Ubuntu 14.04 server cloud amd64 is present"
      local_action: stat path={{ http_boot_folder }}/ubuntu-14.04-server-cloudimg-amd64.tar.gz
      register: test_core_os_image_present
    - name: "Download CoreOS image"
      local_action: get_url url=http://cloud-images.ubuntu.com/releases/trusty/release/ubuntu-14.04-server-cloudimg-amd64.tar.gz dest={{ http_boot_folder }}/ubuntu-14.04-server-cloudimg-amd64.tar.gz
      when: test_core_os_image_present.stat.exists == false
